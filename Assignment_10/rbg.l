; File: rbg.l


; Task 1: RBG-String -------------------------------------------------
(setf *limit* 25)

(defmethod rbg()
	(nth (random 3) '(r b g))
)

(defmethod rbg-string()
	(generate *limit*)
)

(defmethod generate(number)
	(if (equal number 0)
		(list)
		(cons (rbg) (generate (- number 1)))
	)
)


; Task 2: Mutation --------------------------------------------------
( defmethod mutation ( ( rbg-str list ) &aux position symbol )
	( setf position ( random ( length rbg-str ) ) )
	( setf symbol ( others '( r b g ) ( nth position rbg-str ) ) )
	( change rbg-str ( pick symbol ) position )
)

(defmethod others(group unwanted)
	(remove unwanted group)
)

(defmethod pick(group)
	(nth (random (length group)) group)
)

(defmethod change(oldList newElement spot &aux newList)
	(setf newList (copy-list oldList))
	(setf (nth spot newList) newElement)
	newList
)


; Task 3: Crossover --------------------------------------------------
( defmethod crossover ( ( m list ) ( f list ) &aux pos)
	( setf pos ( + 1 ( random ( length m ) ) ) )
	( append ( first-n m pos ) ( rest-n f pos ) )
)

(defmethod first-n((l list) pos &aux newPos)
	(setf newPos (- pos 1))
	(cond
		((>= newPos (length l))
			(first-n l newPos)
		)
		((>= newPos 0)
			(append (first-n l newPos) (list (nth newPos l)))
		)
		(t
			(list)
		)
	)
)

(defmethod rest-n((l list) pos)
	(cond
		((>= pos (length l))
			(list)
		)
		(t
			(append (list (nth pos l)) (rest-n l (+ pos 1)))
		)
	)
)


; Task 4: Demos for Mutation and Crossover ----------------------------
( defmethod mutation-demo (&aux s m)
	( setf s ( rbg-string ) )
	( dotimes ( i 10 )
		( format t "s = ~A~%" s )
		( setf m ( mutation s ) )
		( format t "m = ~A~%~%" m )
	)
)

( defmethod crossover-demo (&aux m f x)
	( setf m ( rbg-string ) )
	( setf f ( rbg-string ) )
	( dotimes ( i 10 )
		( format t "m = ~A~%" m )
		( setf x ( crossover m f ) )
		( format t "x = ~A~%" x )
		( format t "f = ~A~%~%" f )
	)
)


; Task 5: The Fitness Metric ------------------------------------------
(defmethod fitness-r ((rbg-string list))
	(count 'r rbg-string)
)

(defmethod fitness-b ((rbg-string list))
	(count 'b rbg-string)
)

(defmethod fitness-g ((rbg-string list))
	(count 'g rbg-string)
)

( defmethod fitness-demo (&aux x fitness)
	( setf x (rbg-string) )
	( format t "x = ~A~%" x )
	( format t "Directly applying the fitness metrics ...~%" )
	( format t "fitness-r = ~A~%" ( fitness-r x ) )
	( format t "fitness-b = ~A~%" ( fitness-b x ) )
	( format t "fitness-g = ~A~%" ( fitness-g x ) )
	( format t "Indirectly applying the fitness metrics ...~%" )
	( setf fitness #'fitness-r )
	( format t "fitness-r = ~A~%" ( funcall fitness x ) )
	( setf fitness #'fitness-g )
	( format t "fitness-g = ~A~%" ( funcall fitness x ) )
	( setf fitness #'fitness-b )
	( format t "fitness-b = ~A~%" ( funcall fitness x ) )
)


; Task 6: The Individual Class ----------------------------------------
( defclass individual ()
	(
		( rbg-string :accessor individual-rbg-string :initarg :rbg-string )
		( fitness :accessor individual-fitness :initarg :fitness )
		( number :accessor individual-number :initarg :number )
	)
)

( defmethod random-individual (&aux rbg)
	( setf rbg ( rbg-string ) )
	( make-instance 'individual
		:rbg-string rbg
		:fitness ( funcall *fitness* rbg )
		:number 0
	)
)

( defmethod new-individual ( ( nr number ) ( notes list ) )
	( make-instance 'individual
		:rbg-string notes
		:fitness ( funcall *fitness* notes )
		:number nr
	)
)

( defmethod display ( ( i individual ) )
	( display-nnl i ) ( terpri )
)

( defmethod display-nnl ( ( i individual ) )
	( prin1 ( individual-number i ) )
	( princ ( filler ( individual-number i ) ) )
	( prin1 ( individual-rbg-string i ) )
	( princ " " )
	( prin1 ( individual-fitness i ) )
	( princ ( filler ( individual-fitness i ) ) )
)

( defmethod filler ( ( n number ) )
	( cond
		( ( < n 10 ) "     " )
		( ( < n 100 ) "    " )
		( ( < n 1000 ) "   " )
		( ( < n 10000 ) "  " )
		( ( < n 100000 ) " " )
	)
)

( defmethod fitness-b ( ( i individual ) )
	( fitness-b ( individual-rbg-string i ) )
)

( defmethod fitness-r ( ( i individual ) )
	( fitness-r ( individual-rbg-string i ) )
)

( defmethod fitness-g ( ( i individual ) )
	( fitness-g ( individual-rbg-string i ) )
)

( defmethod individual-demo (&aux i0 i1 i2 i3 one two three)
	( setf *fitness* #'fitness-r )
	( setf i0 ( random-individual ) )
	( display i0 )
	( setf one ( rbg-string ) )
	( setf i1 ( new-individual 1 one ) )
	( display i1 )
	( setf two ( rbg-string ) )
	( setf i2 ( new-individual 2 two ) )
	( display i2 )
	( setf three ( rbg-string ) )
	( setf i3 ( new-individual 3 three ) )
	( display i3 )
	( format t "Fitness of i0 = ~A~%" ( funcall *fitness* i0 ) )
	( format t "Fitness of i1 = ~A~%" ( funcall *fitness* i1 ) )
	( format t "Fitness of i2 = ~A~%" ( funcall *fitness* i2 ) )
	( format t "Fitness of i3 = ~A~%" ( funcall *fitness* i3 ) )
	nil
)


; Task 7: The Population Class ------------------------------------------
( defconstant *population-size* 100 )
( defconstant *selection-size* 8 )

( setf *fitness* #'fitness-b )

( defclass population ()
	(
		( individuals :accessor population-individuals :initarg :individuals )
		( generation :accessor population-generation :initform 0 )
	)
)

( defmethod size ( ( p population ) )
	( length ( population-individuals p ) )
)

( defmethod display ( ( p population ) )
	( terpri ) ( terpri )
	( princ "Generation " )
	( prin1 ( population-generation p ) )
	( princ " population ..." )
	( terpri )
	( dolist ( i ( population-individuals p ) )
		( display i )
	)
	( terpri )
)

( defmethod initial-population ( &aux individuals )
	( setf individuals () )
	( dotimes ( i *population-size* )
		( push ( new-individual ( + i 1 ) ( rbg-string ) ) individuals )
	)
	( make-instance 'population :individuals ( reverse individuals ) )
)

( defmethod average ( ( p population ) &aux ( sum 0 ) individuals)
	(setf individuals (population-individuals p))
	(dotimes (i *population-size*)
		(setf sum (+ sum (funcall *fitness* (nth i individuals))))
	)
	(/ sum (float *population-size*))
)

( setf *select-demo* nil )

( defmethod select-individual ( ( p population ) &aux i candidates rn )
	( setf candidates ( select-individuals p ) )
	( setf mfi ( most-fit-individual candidates ) )
	( if *select-demo* ( select-demo-helper candidates mfi) )
	mfi
)

( defmethod select-individuals ( ( p population ) &aux individuals candidates rn )
	( setf individuals ( population-individuals p ) )
	( setf candidates () )
	( dotimes ( i *selection-size* )
		( setf rn ( random *population-size* ) )
		( push ( nth rn individuals ) candidates )
	)
	candidates
)

; Sometimes when the world suddenly changes color, the most-fit individual could have a fitness of 0
( defmethod most-fit-individual ( ( l list ) &aux max-value max-individual individual fitness)
	(setf max-value 0)
	(setf max-individual nil)
	(dotimes (i (length l))
		(setf individual (nth i l))
		(setf fitness (funcall *fitness* individual))
		(cond 
			((>= fitness max-value)
				(setf max-value fitness)
				(setf max-individual individual)
			)
		)
	)
	max-individual
)

( defmethod select-demo-helper ( ( l list ) ( i individual ) )
	( princ "the sample of individuals ..." ) ( terpri )
	( mapcar #'display l )
	( terpri )
	( princ "the most fit of the sample ... " ) ( terpri )
	( display i )
	( terpri )
	nil
)

( defmethod population-demo (&aux p)
	( setf p ( initial-population ) )
	( display p )
	( format t "Average fitness = ~A~%~%" ( average p ) )
	( setf *select-demo* t )
	( format t "Sampling ...~%~%" )
	( select-individual p ) ( terpri)
	( format t "Sampling ...~%~%" )
	( select-individual p ) ( terpri)
	( format t "Sampling ...~%~%" )
	( select-individual p ) ( terpri)
)


; Task 8: Incorporating Mutation
( defmethod mutate ( ( i individual ) &aux mutation )
	( setf mutation ( mutation ( individual-rbg-string i ) ) )
	( make-instance 'individual
		:number ( individual-number i )
		:rbg-string mutation
		:fitness ( funcall *fitness* mutation )
	)
)

( defconstant *pc-m* 50 )

( defmethod maybe-mutate ( ( i individual ) )
	( if ( <= ( + 1 ( random 100 ) ) *pc-m* )
		( mutate i )
		i
	)
)

( defmethod mutate-demo ()
	( setf i ( random-individual ) )
	( display i )
	( dotimes ( x 20 )
		( setf i ( mutate i ) )
		( display i )
	)
)

( defmethod maybe-mutate-demo ()
	( setf i ( random-individual ) )
	( display i )
	( dotimes ( x 20 )
		( setf n ( maybe-mutate i ) )
		( display-nnl n )
		( if ( not ( equal n i ) ) ( princ " *" ) )
		( terpri )
		( setf i n )
	)
)


; Task 9: Copy
( setf *copy-demo* nil )

( defconstant *pc-c* 40 )

( defmethod perform-copies ( ( cp population ) ( np population))
	( dotimes ( i ( nr-copies ) )
		( perform-one-copy cp np )
	)
)

( defmethod nr-copies ()
	( * ( / *pc-c* 100 ) *population-size* )
)

( defmethod perform-one-copy ( ( cp population ) ( np population ) &aux x m mm new-i )
	( setf m ( select-individual cp ) )
	( if *copy-demo* ( format t "Selected individual = ~%" ) )
	( if *copy-demo* ( display m ) )
	( setf mm ( maybe-mutate m ) )
	( if *copy-demo* ( format t "Possibly muted individual = ~&" ) )
	( if *copy-demo* ( display mm ) )
	( setf ( individual-number mm ) ( + 1 ( size np ) ) )
	( if *copy-demo* ( format t "Renumbered individual = ~&" ) )
	( if *copy-demo* ( display mm ) )
	( setf new-i ( new-individual ( + 1 ( size np ) ) ( individual-rbg-string mm ) ) )
	( setf
		( population-individuals np )
		( append ( population-individuals np ) ( list new-i ) )
	)
	nil
)

( defmethod empty-population ( ( cp population ) &aux np )
	( setf np ( make-instance 'population ) )
	( setf ( population-individuals np ) () )
	( setf ( population-generation np ) ( + 1 ( population-generation cp ) ) )
	np
)

( defmethod perform-copies-demo ( &aux cp np )
	( setf cp ( initial-population ) )
	( setf np ( empty-population cp ) )
	( format t "---------------------------------------------------------------------------~%~%")
	( display np )
	( format t "~%~%---------------------------------------------------------------------------~%")
	( setf *select-demo* t )
	( setf *copy-demo* t )
	( dotimes ( i 10 )
		( perform-one-copy cp np )
		( format t "---------------------------------------------------------------------------~%~%")
		( display np )
		( format t "~%~%---------------------------------------------------------------------------~%")
	)
	( setf *select-demo* nil )
	( setf *copy-demo* nil )
	nil
)


; Task 10: Crossover
( setf *crossover-demo* nil )

( defconstant *pc-x* 60 )

( defmethod perform-crossovers ( ( cp population ) ( np population ) )
	( dotimes ( i ( nr-crossovers ) )
		( perform-one-crossover cp np )
	)
)

( defmethod nr-crossovers ()
	( * ( / *pc-x* 100 ) *population-size* )
)

( defmethod perform-one-crossover ( ( cp population ) ( np population ) )
	( let ( x m mm mother father new-i )
		( setf mother ( select-individual cp ) )
		( setf father ( select-individual cp ) )
		( if *crossover-demo* ( format t "Selected mother = ~%" ) )
		( if *crossover-demo* ( display mother ) )
		( if *crossover-demo* ( format t "Selected father = ~&" ) )
		( if *crossover-demo* ( display father ) )
		( setf m ( crossover mother father ) )
		( if *crossover-demo* ( format t "the crossover = ~&" ) )
		( if *crossover-demo* ( display m ) )
		( setf mm ( maybe-mutate m ) )
		( if *crossover-demo* ( format t "the possibly mutated individual = ~&" ) )
		( if *crossover-demo* ( display mm ) )
		( setf ( individual-number mm ) ( + 1 ( size np ) ) )
		( if *crossover-demo* ( format t "the renumbered individual = ~&" ) )
		( if *crossover-demo* ( display mm ) )
		( setf new-i ( new-individual ( + 1 ( size np ) ) ( individual-rbg-string mm ) ))
		( setf
			( population-individuals np )
			( append ( population-individuals np ) ( list new-i ) )
		)
	)
	nil
)

; The inner crossover function called here takes the rbg-string, 
; which is a previously established function
( defmethod crossover ( ( mother individual ) ( father individual ) &aux mi fi x i )
	( setf mi (individual-rbg-string mother ) )
	( setf fi (individual-rbg-string father ) )
	( setf x ( crossover mi fi ) )
	( setf i ( new-individual 0 x ) )
	i
)

( defmethod perform-crossovers-demo ( &aux cp np )
	( setf cp ( initial-population ) )
	( setf np ( empty-population cp ) )
	( format t "-------------------------------------------------------------------------~%~%" )
	( display np )
	( format t "~%~%-------------------------------------------------------------------------~%" )
	( setf *select-demo* t )
	( setf *crossover-demo* t )
	( dotimes ( i 10 )
		( perform-one-crossover cp np )
		( format t "-------------------------------------------------------------------------~%~%" )
		( display np )
		( format t "~%~%-------------------------------------------------------------------------~%" )
	)
	( setf *select-demo* nil )
	( setf *crossover-demo* nil )
	nil
)


; Task 11: The GA
;; THE NEXT GENERATION METHOD FOR THE GA
( defmethod next-generation ( ( cp population ) &aux np )
	( setf np ( empty-population cp ) )
	( perform-copies cp np )
	( perform-crossovers cp np )
	np
)

;; THE GA!
( defconstant *nr-generations* 25 )

( defmethod ga ( &aux p )
	( format t "THE WORLD IS BLUE ~%~%" )
	( setf *fitness* #'fitness-b )
	( setf p ( initial-population ) )
	( terpri )
	( summarize p )
	( dotimes ( i *nr-generations* )
		( setf p ( next-generation p ) )
		( check-average p )
	)
	( terpri )
	( summarize p )
	( format t "THE WORLD IS RED ~%~%" )
	( setf *fitness* #'fitness-r )
	( dotimes ( i *nr-generations* )
		( setf p ( next-generation p ) )
		( check-average p )
	)
	( terpri )
	( summarize p )
	( format t "THE WORLD IS GREEN ~%~%" )
	( setf *fitness* #'fitness-g )
	( dotimes ( i *nr-generations* )
		( setf p ( next-generation p ) )
		( check-average p )
	)
	( terpri )
	( summarize p )
)

;; METHODS TO PROVIDE INFORMATION ON "PROGRESS"
( defmethod summarize ( ( p population ) )
	( display p )
	( check-average p )
	( terpri )
)

( defmethod check-average ( ( p population ) )
	( format t "average fitness of population ~A = ~A~%"
		( population-generation p )
		( average p )
	)
)